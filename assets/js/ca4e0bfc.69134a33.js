"use strict";(self.webpackChunkmindspaces=self.webpackChunkmindspaces||[]).push([[5528],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),h=u(n),p=o,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||r;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[h]="string"==typeof e?e:o,s[1]=i;for(var u=2;u<r;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6037:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:20},s="Web Application",i={unversionedId:"development/frontend",id:"development/frontend",title:"Web Application",description:"This article will cover architecture of the web app, we will go over which framework we are using, how we are managing state, how we are fetching data, how we handle routing, and how we are styling our components.",source:"@site/docs/development/frontend.md",sourceDirName:"development",slug:"/development/frontend",permalink:"/docs/development/frontend",draft:!1,editUrl:"https://github.com/Mindspace-Fontys/mindspace-fontys.github.io/edit/main/docs/development/frontend.md",tags:[],version:"current",lastUpdatedBy:"Kane",lastUpdatedAt:1678713911,formattedLastUpdatedAt:"Mar 13, 2023",sidebarPosition:20,frontMatter:{sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Version Control",permalink:"/docs/development/git"},next:{title:"Tooling",permalink:"/docs/development/tooling/"}},l={},u=[{value:"Framework",id:"framework",level:2},{value:"Schema Validation",id:"schema-validation",level:2},{value:"Managing State",id:"managing-state",level:2},{value:"Data fetching",id:"data-fetching",level:2},{value:"Routing",id:"routing",level:2},{value:"Styling",id:"styling",level:2}],c={toc:u},h="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"web-application"},"Web Application"),(0,o.kt)("p",null,"This article will cover architecture of the web app, we will go over which framework we are using, how we are managing state, how we are fetching data, how we handle routing, and how we are styling our components."),(0,o.kt)("h2",{id:"framework"},"Framework"),(0,o.kt)("p",null,"We are using ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React")," as the framework for our web application. We are using ",(0,o.kt)("a",{parentName:"p",href:"https://vitejs.dev/"},"Vite")," as the build tool for a better development experience. We are also using ",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"Typescript")," on top of React to make our code more robust and maintainable."),(0,o.kt)("p",null,"For learning React, we recommend using the improved ",(0,o.kt)("a",{parentName:"p",href:"https://beta.reactjs.org/"},"Beta Docs"),", although not everything is supported in the Beta Docs, it is still a great resource to learn React. And if a subject is not available in the Beta Docs, you can always check the ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"Legacy Docs"),'. We suggest that you use the "Get Started" and "Learn React" sections of the Beta Docs to start off.'),(0,o.kt)("h2",{id:"schema-validation"},"Schema Validation"),(0,o.kt)("p",null,"As for schema validation, we are using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/colinhacks/zod"},"Zod"),", Zod allows you to define a schema for your data, and then validate your data against that schema. This is useful for validating data that is coming from the backend, or data that is being sent to the backend. Zod also allows you to get the type of the schema, which is useful in collaboration with Typescript."),(0,o.kt)("p",null,"In the example below we will show you how to work with zod, and how to get the type of the schema."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { z } from "zod";\n\n//Here we define a schema for a user, a user is an object that has an id, name, and optionally an email.\nconst userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string().optional(),\n});\n\n// Here we extract the type of the schema, this will give us the type User, \n// which is an object with the same properties as the schema.\n// This will result in the following type:\n// type User = {\n//   id: string;\n//   name: string;\n//   email?: string;\n// };\ntype User = z.infer<typeof userSchema>;\n\n// Now we will define a user, and validate it against the schema.\nconst user = {\n  id: "123",\n  name: "John Doe",\n};\n\nconst parsedUser = userSchema.safeParse(user);\nif (!parsedUser.success) {\n  // If the user does not match the schema, we will throw an error.\n  throw new Error(parsedUser.error);\n}\n\n// If the parse is succesfull we can get the data from the parsedUser object.\nconst parsedUserValue = parsedUser.data;\n')),(0,o.kt)("h2",{id:"managing-state"},"Managing State"),(0,o.kt)("p",null,"For managing state we are using ",(0,o.kt)("a",{parentName:"p",href:"%22https://jotai.org/%22"},"Jotai"),", because it is a simple and lightweight state management library. It is also very easy to use, and it is very well documented. We recommend that you read the ",(0,o.kt)("a",{parentName:"p",href:"https://jotai.org/docs/getting-started"},"Getting Started")," section of the Jotai docs to get started. It uses the atom pattern, which is a simple pattern that allows you to create stateful values, and then use them in your components. It also allows you to scope your state to children of components using stores.  In the example below we will show you how to use atoms."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { atom, useAtom } from "jotai";\n\n//First we define an atom, with a default value of 0.\nconst countAtom = atom(0);\n\nconst Counter = () => {\n  //In the counter component we will use the atom, and get the current value of the atom, and a function to set the value of the atom.\n  const [count, setCount] = useAtom(countAtom);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\n')),(0,o.kt)("p",null,"In the example below we will showw you how to create scoped state using stores."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { atom, createStore, Provider } from "jotai";\n\n\n//First we define an atom, we want to use in our store.\nexport const countAtom = atom(0);\n\n//Then we create a store.\nexport const CounterStore = createStore();\n\n//Now we will add the atom to the store, with the actual default value.\nCounterStore.set(countAtom, 83);\n\nconst CounterPage = () => {\n    return <Provider store={CounterStore}></Provider>\n}\n\nconst Counter = () => {\n  //In the counter component we will use the store to get the local value of the atom.\n  const store = useStore();\n  //By using store.get we will get the local value of the atom, which is 83.\n  const count = store.get(countAtom);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => store.set(countAtom, count + 1)}>Increment</button>\n    </div>\n  );\n};\n\n')),(0,o.kt)("h2",{id:"data-fetching"},"Data fetching"),(0,o.kt)("p",null,"For a better developer experience, we are using ",(0,o.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/"},"React Query")," for fetching data. It is a simple library that allows you to fetch data from the backend, and then use that data in your components. It also allows you to cache the data, and invalidate the cache when needed. In the example below we will show you how to use the useQuery which is maily used to get data. In the second example we will show you how to use the useMutation hook, which is mainly used to send data to the backend."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useQuery } from 'react-query';\n\nconst UserList = () => {\n  const { isLoading, error, data } = useQuery('users', () =>\n    fetch('https://api.endpoint').then((res) =>\n    {\n        if (!res.ok) {\n            throw new Error('Failed to fetch users')\n\n        return res.json()\n    })\n  );\n\n  if (isLoading)\n    return <div>Loading...</div>;\n\n  if (error)\n    return <div>Error: {error.message}</div>;\n\n  return (\n    <ul>\n      {data.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n")),(0,o.kt)("p",null,"In this example, we're using the useQuery hook to fetch a list of users from a remote API. The first argument to useQuery is a unique key for this query (in this case, 'users'), and the second argument is a function that returns a promise which resolves with the data for this query."),(0,o.kt)("p",null,"The hook returns an object with three properties: isLoading (a boolean indicating whether the query is currently loading), error (an error object if the query failed), and data (the data returned by the query)."),(0,o.kt)("p",null,"We're rendering different content depending on the state of the query. If isLoading is true, we're showing a \"Loading...\" message. If error is truthy, we're showing an error message. Otherwise, we're rendering the list of users returned by the query."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useMutation } from 'react-query';\n\nconst UserForm = () => {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n\n  const {mutate, isLoading, error } = useMutation(\n    (newUser) => fetch('https://api.endpoint', {\n      method: 'POST',\n      body: JSON.stringify(newUser),\n    }),\n    {\n      onSuccess: () => {\n        // Invalidate and refetch\n        queryClient.invalidateQueries('users')\n      },\n    }\n  )\n\n  const handleSubmit = (e) => {\n    e.preventDefault()\n    mutate({ name, email })\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        placeholder=\"Enter name\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n      />\n      <input\n        type=\"email\"\n        placeholder=\"Enter email\"\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n      />\n      <button type=\"submit\" disabled={isLoading}>\n        {isLoading ? 'Loading...' : 'Submit'}\n      </button>\n      {error && <div>{error.message}</div>}\n    </form>\n  )\n}\n")),(0,o.kt)("p",null,"For fetching the data itself we are using ZodFetch which is a small wrapper around the default fetch function. It allows you to validate the data that you get from the backend. In the example below we will show you how to use ZodFetch."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { z } from "zod";\nimport { SafeFetch } from "../utils"\n\n//Here we define a schema for a user, a user is an object that has an id, name, and optionally an email.\nconst userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string().optional(),\n});\n\n//Here we define a function that will fetch a user from the backend, and validate the data that we get from the backend.\nexport const FetchUser = async () => {\n    //Here we call the SafeFetch function, and pass in the schema, and the url of the endpoint. \n    //The SafeFetch will throw an error if the data does not match the schema, and if the request fails.\n    return await SafeFetch(userSchema, "https://api.endpoint")\n}\n\n')),(0,o.kt)("h2",{id:"routing"},"Routing"),(0,o.kt)("p",null,"For routing we are using ",(0,o.kt)("a",{parentName:"p",href:"https://reactrouter.com/"},"React Router"),". We will be using the browser router, this means that we will be using the url to navigate between pages. In the example below we will show you how to use the browser router."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { createBrowserRouter } from "react-router-dom";\nimport { HomePage } from "./pages/HomePage";\nimport { AboutPage } from "./pages/AboutPage";\n\nexport const createBrowserRouter([{\n    path: "/",\n    component: <HomePage />,\n    exact: true,\n}, \n{\n    path: "/about",\n    component: <AboutPage />,\n    exact: true,\n}])\n')),(0,o.kt)("p",null,"As you can is it is very easy to add new routes to the application. You just need to add a new object to the array. The path is the url that you want to navigate to, the component is the component that you want to render when you navigate to that url, and the exact is a boolean that tells the router if it should match the exact url or not."),(0,o.kt)("h2",{id:"styling"},"Styling"),(0,o.kt)("p",null,"We are using Mantine for styling our components. We chose mantine because it is easy to extend, and it is very customizable. It also has a lot of components that we can use to build our application. In the example below we will show you how to use the Button component from Mantine, we will override the styles of the button, and we will add a custom class to the button."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { Button } from "@mantine/core";\n\nexport const MyButton = () => {\n    return <Button \n        styles={(theme) => ({\n          root: {\n            backgroundColor: theme.colors.blue[1],\n            border: 0,\n            height: rem(42),\n            paddingLeft: rem(20),\n            paddingRight: rem(20),\n          }\n        })}\n        >\n        custom styled button\n    </Button>\n}\n')))}d.isMDXComponent=!0}}]);